// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
//
//	C O N V E R S I O N
//		WIP conversion, we are converting a song
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
//
//	mysong_timesig
//	mysong_fretbars
//
//	-- GUITAR: -------------
//	mysong_song_Easy
//	mysong_song_Medium
//	mysong_song_Hard
//	mysong_song_Expert
//		mysong_Easy_Star
//		mysong_Medium_Star
//		mysong_Hard_Star
//		mysong_Expert_Star
//			mysong_Easy_StarBattleMode
//			mysong_Medium_StarBattleMode
//			mysong_Hard_StarBattleMode
//			mysong_Expert_StarBattleMode
//		mysong_Easy_Tapping
//		mysong_Medium_Tapping
//		mysong_Hard_Tapping
//		mysong_Expert_Tapping
//			mysong_Easy_WhammyController
//			mysong_Medium_WhammyController
//			mysong_Hard_WhammyController
//			mysong_Expert_WhammyController
//		mysong_FaceOffStar
//		mysong_FaceOffP1
//		mysong_FaceOffP2
//
//	-- RHYTHM: -------------
//	mysong_song_rhythm_Easy
//	mysong_song_rhythm_Medium
//	mysong_song_rhythm_Hard
//	mysong_song_rhythm_Expert
//		mysong_rhythm_Easy_Star
//		mysong_rhythm_Medium_Star
//		mysong_rhythm_Hard_Star
//		mysong_rhythm_Expert_Star
//			mysong_rhythm_Easy_StarBattleMode
//			mysong_rhythm_Medium_StarBattleMode
//			mysong_rhythm_Hard_StarBattleMode
//			mysong_rhythm_Expert_StarBattleMode
//		mysong_rhythm_Easy_Tapping
//		mysong_rhythm_Medium_Tapping
//		mysong_rhythm_Hard_Tapping
//		mysong_rhythm_Expert_Tapping
//			mysong_rhythm_Easy_WhammyController
//			mysong_rhythm_Medium_WhammyController
//			mysong_rhythm_Hard_WhammyController
//			mysong_rhythm_Expert_WhammyController
//		mysong_rhythm_FaceOffStar
//		mysong_rhythm_FaceOffP1
//		mysong_rhythm_FaceOffP2
//
//	-- DRUMS: --------------
//	mysong_drum_Easy
//	mysong_drum_Medium
//	mysong_drum_Hard
//	mysong_drum_Expert
//		mysong_drum_Easy_Star
//		mysong_drum_Medium_Star
//		mysong_drum_Hard_Star
//		mysong_drum_Expert_Star
//			mysong_drum_Easy_StarBattleMode
//			mysong_drum_Medium_StarBattleMode
//			mysong_drum_Hard_StarBattleMode
//			mysong_drum_Expert_StarBattleMode
//		mysong_drum_Easy_Tapping
//		mysong_drum_Medium_Tapping
//		mysong_drum_Hard_Tapping
//		mysong_drum_Expert_Tapping
//			mysong_drum_Easy_WhammyController
//			mysong_drum_Medium_WhammyController
//			mysong_drum_Hard_WhammyController
//			mysong_drum_Expert_WhammyController
//		mysong_drum_FaceOffStar
//		mysong_drum_FaceOffP1
//		mysong_drum_FaceOffP2
//			mysong_Easy_DrumFill
//			mysong_Medium_DrumFill
//			mysong_Hard_DrumFill
//			mysong_Expert_DrumFill
//		mysong_Easy_DrumUnmute
//		mysong_Medium_DrumUnmute
//		mysong_Hard_DrumUnmute
//		mysong_Expert_DrumUnmute
//
//	-- VOCALS: --------------------
//	mysong_vocals
//	mysong_vocals_freeform
//	mysong_vocals_phrases
//	mysong_vocals_note_range
//	mysong_lyrics
//	mysong_vocals_markers
//
//	-- OTHER (EMPTY): -------------
//	mysong_song_aux_Easy
//	mysong_song_aux_Medium
//	mysong_song_aux_Hard
//	mysong_song_aux_Expert
//		mysong_aux_Easy_Star
//		mysong_aux_Medium_Star
//		mysong_aux_Hard_Star
//		mysong_aux_Expert_Star
//			mysong_aux_Easy_StarBattleMode
//			mysong_aux_Medium_StarBattleMode
//			mysong_aux_Hard_StarBattleMode
//			mysong_aux_Expert_StarBattleMode
//		mysong_aux_Easy_Tapping
//		mysong_aux_Medium_Tapping
//		mysong_aux_Hard_Tapping
//		mysong_aux_Expert_Tapping
//			mysong_aux_Easy_WhammyController
//			mysong_aux_Medium_WhammyController
//			mysong_aux_Hard_WhammyController
//			mysong_aux_Expert_WhammyController
//		mysong_aux_FaceOffStar
//		mysong_aux_FaceOffP1
//		mysong_aux_FaceOffP2
//
//	-- GUITAR COOP (KEEP EMPTY): -------------
//	mysong_song_guitarcoop_Easy
//	mysong_song_guitarcoop_Medium
//	mysong_song_guitarcoop_Hard
//	mysong_song_guitarcoop_Expert
//		mysong_guitarcoop_Easy_Star
//		mysong_guitarcoop_Medium_Star
//		mysong_guitarcoop_Hard_Star
//		mysong_guitarcoop_Expert_Star
//			mysong_guitarcoop_Easy_StarBattleMode
//			mysong_guitarcoop_Medium_StarBattleMode
//			mysong_guitarcoop_Hard_StarBattleMode
//			mysong_guitarcoop_Expert_StarBattleMode
//		mysong_guitarcoop_Easy_Tapping
//		mysong_guitarcoop_Medium_Tapping
//		mysong_guitarcoop_Hard_Tapping
//		mysong_guitarcoop_Expert_Tapping
//			mysong_guitarcoop_Easy_WhammyController
//			mysong_guitarcoop_Medium_WhammyController
//			mysong_guitarcoop_Hard_WhammyController
//			mysong_guitarcoop_Expert_WhammyController
//		mysong_guitarcoop_FaceOffStar
//		mysong_guitarcoop_FaceOffP1
//		mysong_guitarcoop_FaceOffP2
//
//	-- RHYTHM COOP (KEEP EMPTY): -------------
//	mysong_song_rhythmcoop_Easy
//	mysong_song_rhythmcoop_Medium
//	mysong_song_rhythmcoop_Hard
//	mysong_song_rhythmcoop_Expert
//		mysong_rhythmcoop_Easy_Star
//		mysong_rhythmcoop_Medium_Star
//		mysong_rhythmcoop_Hard_Star
//		mysong_rhythmcoop_Expert_Star
//			mysong_rhythmcoop_Easy_StarBattleMode
//			mysong_rhythmcoop_Medium_StarBattleMode
//			mysong_rhythmcoop_Hard_StarBattleMode
//			mysong_rhythmcoop_Expert_StarBattleMode
//		mysong_rhythmcoop_Easy_Tapping
//		mysong_rhythmcoop_Medium_Tapping
//		mysong_rhythmcoop_Hard_Tapping
//		mysong_rhythmcoop_Expert_Tapping
//			mysong_rhythmcoop_Easy_WhammyController
//			mysong_rhythmcoop_Medium_WhammyController
//			mysong_rhythmcoop_Hard_WhammyController
//			mysong_rhythmcoop_Expert_WhammyController
//		mysong_rhythmcoop_FaceOffStar
//		mysong_rhythmcoop_FaceOffP1
//		mysong_rhythmcoop_FaceOffP2
//
//	-- BOSS BATTLE (KEEP EMPTY): -------------
//	mysong_BossBattleP1
//	mysong_BossBattleP2
//
//	------------------------------------------
//	mysong_guitar_markers
//	mysong_rhythm_markers (EMPTY)
//	mysong_drum_markers (EMPTY)
//	mysong_anim_notes
//	mysong_triggers_notes
//	mysong_cameras_notes
//	mysong_lightshow_notes
//	mysong_crowd_notes
//	mysong_drums_notes
//	mysong_scripts
//	mysong_anim
//	mysong_triggers
//	mysong_cameras
//	mysong_lightshow
//	mysong_crowd
//	mysong_drums
//	mysong_performance
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

const DEFAULT_TAP_BUFFER = 115;

const DRUM_FILL_MIN_TIME = 3.0;
const DRUM_FILL_AUTOGEN = false;

const LEFTHAND_MIN_GUITAR = 109;
const LEFTHAND_MIN_BASS = 85;
const LEFTHAND_AMOUNT = 18;

const Foreigns = [
	"øo",
	"áa", "ÁA", "ée", "ÉE", "íi", "ÍI", "óo", "ÓO", "úu", "ÚU", "ýy", "ÝY",
	"âa", "ÂA", "êe", "ÊE", "îi", "ÎI", "ôo", "ÔO", "ûu", "ÛU",
	"äa", "ÄA", "ëe", "ËE", "ïi", "ÏI", "öo", "ÖO", "üu", "ÜU",
	"àa", "ÀA", "èe", "ÈE", "ìi", "ÌI", "òo", "ÒO", "ùu", "ÙU",
	"ãa", "ÃA", "ñn", "ÑN", "õo", "ÕO", "çc","ÇC"
];

const QBDiffs = ["easy", "medium", "hard", "expert"];

// Instruments that need to be added
const QBInstruments = [

	// Guitar!
	{
		noteID: "song",
		subID: "",
		instrument: "guitar"
	},
	
	// Rhythm / Bass
	{
		noteID: "song_rhythm",
		subID: "rhythm",
		instrument: "bass"
	},
	
	// Drums
	{
		noteID: "song_drum",
		subID: "drum",
		instrument: "drums"
	},

	// Mic / aux, temporary
	{
		noteID: "song_aux",
		subID: "aux",
		instrument: "mic_donotuse"
	},
	
	// Guitar coop, temporary
	{
		noteID: "song_guitarcoop",
		subID: "guitarcoop",
		instrument: "guitarcoop_donotuse"
	},
	
	// Rhythm coop, temporary
	{
		noteID: "song_rhythmcoop",
		subID: "rhythmcoop",
		instrument: "rhythmcoop_donotuse"
	}
];

// These will be filled with null values
const JunkArrays = [
	"mysong_rhythm_markers",
	"mysong_drum_markers",
	"mysong_triggers_notes",
	"mysong_scripts_notes",
	"mysong_crowd_notes",
	"mysong_scripts",
	"mysong_anim",
	"mysong_triggers",
	"mysong_cameras",
	"mysong_lightshow",
	"mysong_crowd",
	"mysong_drums"
];

const path = require('path');
const fs = require('fs');

var cls;

class Conversion
{
	constructor(opt = {})
	{
		this.converter = opt.converter;
		this.checksum = opt.checksum;
		
		this.inDir = opt.inDir;
		this.outDir = opt.outDir || __dirname;
		
		cls = GHSDK.QBHandler.ItemTypes.classes;
		
		// Read custom lightshow array, if it exists
		this.customLightshow = null;
		var lsPath = path.join(this.inDir, 'lightshow.array.txt');
		if (fs.existsSync(lsPath))
		{
			this.customLightshow = [];
			var lines = fs.readFileSync(lsPath).toString().split("\n");
			
			for (var line of lines)
				this.customLightshow.push(parseInt(line.trim()));
		}
        
        // Read custom performance array, if it exists
		this.customPerformance = null;
		var lsPath = path.join(this.inDir, 'lightshow.array.txt');
		if (fs.existsSync(lsPath))
		{
			this.customLightshow = [];
			var lines = fs.readFileSync(lsPath).toString().split("\n");
			
			for (var line of lines)
				this.customLightshow.push(parseInt(line.trim()));
		}
		
		// Read song info / INI first
		var songInfo = {};
		var iniPath = path.join(this.inDir, 'song.ini');
		if (fs.existsSync(iniPath))
		{
			cons.log("Parsing INI info...");
			var INI = new GHSDK.Constants.INIHandler();
			INI.Read(iniPath);
            
			songInfo = INI.FindSection('song') || {};
		}
        
		// No checksum, attempt to generate or pull from INI
		if (songInfo.checksum)
			this.checksum = songInfo.checksum[0];
		else if (!this.checksum)
			this.GenerateSongChecksum(songInfo);
			
		// Slap prefix and suffix onto checksum
		if (GHSDK.Config.SC_ChecksumPrefix)
			this.checksum = GHSDK.Config.SC_ChecksumPrefix += this.checksum;
		if (GHSDK.Config.SC_ChecksumSuffix)
			this.checksum += GHSDK.Config.SC_ChecksumSuffix;
			
		var gr = GHSDK.Constants.Chalk.keyword('lime');
		cons.log("Shortened song checksum: " + gr(this.checksum));
		
		songInfo.checksum = [this.checksum];
			
		// Failed to generate
		if (!this.checksum && this.converter.callback)
		{
			this.converter.callback({errors: ["Failed to generate song checksum."]});
			return;
		}
		
		// Before we do anything, parse the MIDI
		cons.log("Converting MIDI file...");
		var mid = path.join(this.inDir, 'notes.mid');
		if (!fs.existsSync(mid))
		{
			this.converter.callback({errors: ["notes.mid not found for song. Does it use chart?"]});
			return;
		}
		
		this.data = this.converter.ParseMIDIData(mid, songInfo);
		
        // ------------------------
        
        var finalMainBuffer = null;
        var mainQB = null;
        var secQB = null;
        
        var mainQBName = "songs/" + this.checksum + ".mid.qb";
        var secQBName = "songs/" + this.checksum + "_song_scripts.qb";
        
        var rawSongFile = path.join(this.inDir, 'song.txt');
        
        if (fs.existsSync(rawSongFile))
        {
            var txtData = fs.readFileSync(rawSongFile).toString();
            var rdr = new GHSDK.QBHandler.ReaderCore();
            
            var res = rdr.CompileText(txtData, mainQBName);
            finalMainBuffer = res;
            
            //~ fs.writeFileSync(path.join(this.outDir, 'song.qb.xen'), res);
        }
        
        else
        {
            // Main song QB file!
            mainQB = this.CreateMainQB();
            
            var w_main = new GHSDK.Constants.Writer();
            mainQB.ToBytesCore_Whole(w_main);
            finalMainBuffer = w_main.buffer;
        }
    
		// Secondary song QB file!
		secQB = this.CreateScriptQB();
		
		// Now let's generate a .pak with our song data!
		var outPak = path.join(this.outDir, 'a' + this.checksum + "_song.pak.xen");
		
		var w_sec = new GHSDK.Constants.Writer();
		secQB.ToBytesCore_Whole(w_sec);
        
        if (!finalMainBuffer)
        {
            cons.error("No main buffer, fail");
            return;
        }
        
        // ------------------------
		
		var pakFiles = [
		
			// Main .qb file
			{
				fullName: mainQBName,
				extension: "qb",
				nameOnly: this.checksum,
				data: finalMainBuffer
			},
			
			// Script .qb file
			{
				fullName: secQBName,
				extension: "qb",
				nameOnly: this.checksum,
				data: w_sec.buffer
			}
		
		];
		
		GHSDK.PakHandler.Compile("", outPak, {extraFiles: pakFiles});
		
		var outFiles = [outPak];
		
		// Skip audio?
		if (!opt.skipAudio)
		{
			this.converter.audioStartTime = new Date();
			
			// Prep audio for FSB's
			var trackmap = this.converter.AudioHandler.PrepareFolder(this.inDir, songInfo);
			if (trackmap.errors)
			{
				this.converter.AudioHandler.CleanupMusic();
				this.converter.callback({errors: trackmap.errors});
				
				return;
			}
			
			trackmap = trackmap.result;
				
			// Generate required FSB files
			var musicDir = path.join(this.outDir, 'MUSIC');
				
			this.converter.FSBHandler.CreateFSBs(this.inDir, musicDir, this.checksum, trackmap, (res) => {
				
				if (!this.converter.callback)
					return;
				
				var cbData = {errors: res.errors, files: outFiles, info: songInfo};
				
				// Output .fsb files
				cbData.files = cbData.files.concat(res.files || []);
				
				this.converter.AudioHandler.CleanupMusic();
				
				this.converter.callback(cbData);
			});
		}
		
		// Skip audio, just return pak
		else if (this.converter.callback)
		{
			this.converter.callback({files: outFiles, info: songInfo});
		}
	}
	
	//-----------------------
	// Create blank array with null times
	//-----------------------
	
	CreateDummyArray(secName, parented = false)
	{
		var op = {itemName: 'SectionArray', id: secName};
		
		if (parented)
			op.parent = this.mainQB;
			
		var sec = new cls.SectionArray(op);
		
		var aff = new cls.Floats({itemName: 'Floats', parent: sec});
		aff.values = [0.0, 0.0];
		
		return aff;
	}
	
	//-----------------------
	// Create dummy section names, for now
	//-----------------------
	
	CreateDummyMarkers(mrkName)
	{
		var sa = new cls.SectionArray({itemName: 'SectionArray', id: mrkName, parent: this.mainQB});
		var saa = new cls.ArrayStruct({itemName: 'ArrayStruct', parent: sa});
		var sh = ItemTypes.Create('StructHeader', {parent: saa});
		var sii = new cls.StructItemInteger({itemName: 'StructItemInteger', id: 'time', value: this.data.fretbars[1], parent: sh});
		var sis = new cls.StructItemString({itemName: 'StructItemString', id: 'marker', value: "\\LNO SECTIONS", parent: sh});
	}
	
	//-----------------------
	// Create REAL section names for an instrument
	//-----------------------
	
	CreateRealMarkers(instrument)
	{
		var secName = this.checksum + "_" + instrument + "_markers";
		var sections = this.converter.sections;
		
		if (sections.length <= 0)
		{
			this.CreateDummyMarkers(secName);
			return;
		}
		
		var sa = new cls.SectionArray({itemName: 'SectionArray', id: secName, parent: this.mainQB});
		var saa = new cls.ArrayStruct({itemName: 'ArrayStruct', parent: sa});
		
		for (const section of sections)
		{
			var sh = ItemTypes.Create('StructHeader', {parent: saa});
			var msTime = Math.floor(section[0] * 1000) + this.converter.songDelay;
			var sii = new cls.StructItemInteger({itemName: 'StructItemInteger', id: 'time', value: msTime, parent: sh});
			var sis = new cls.StructItemString({itemName: 'StructItemString', id: 'marker', value: section[1], parent: sh});
		}
	}
	
	//-----------------------
	// Create dummy star power
	//-----------------------
	
	CreateDummyStarPower(secName)
	{
		var sa = new cls.SectionArray({itemName: 'SectionArray', id: secName, parent: this.mainQB});
		var saa = new cls.ArrayArray({itemName: 'ArrayArray', parent: sa});
		var sai = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: saa});
		sai.values = [0, 50, 10];
	}
	
	//-----------------------
	// Create REAL star power!
	//-----------------------
	
	CreateRealStarPower(secName, starPowers)
	{
		var sa = new cls.SectionArray({itemName: 'SectionArray', id: secName, parent: this.mainQB});
		var saa = new cls.ArrayArray({itemName: 'ArrayArray', parent: sa});
		
		for (const star of starPowers)
		{
			var sai = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: saa});
			sai.values = star;
		}
	}
	
	//-----------------------
	// Create solos
	// (GHWT:DE only)
	//-----------------------
	
	CreateSoloArray(instrument, arrayName)
	{
		var solosToAdd = [];
		
		// Get solo values
		var soloArray = this.data.arrays[instrument + "_solos"] || [];
			
		for (const solo of soloArray)
		{
			var startMS = Math.floor(solo[0] * 1000);
			var endMS = Math.floor((solo[0] + solo[1]) * 1000);
			
			solosToAdd.push([startMS, endMS]);
		}
		
		if (solosToAdd.length <= 0)
			return;
		
		var sa = new cls.SectionArray({itemName: 'SectionArray', id: arrayName, parent: this.mainQB});
		var saa = new cls.ArrayArray({itemName: 'ArrayArray', parent: sa});
		
		for (const solo of solosToAdd)
		{
			var sai = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: saa});
			sai.values = solo;
		}
	}
	
	//-----------------------
	// Create tap notes
	//-----------------------
	
	CreateTapArray(instrument, diff, tapName)
	{
		var sys = this.converter.sysEx[instrument];
		var taps = [];
        var timeToAdd = 0;
        
        if (instrument == 'guitar' || instrument == 'bass')
        {
            // Gets the tap_buffer property from the INI.
            var songInfo = {};
            var iniPath = path.join(this.inDir, 'song.ini');
            var INI = new GHSDK.Constants.INIHandler();
            INI.Read(iniPath);
            
            // User defines the tap note threshold in the song.ini file for a song.
                // If there was no tap buffer defined, use the default of 115 ms.
            songInfo = INI.FindSection('song') || {};

            // Make sure the buffer value is 0 or higher!
            if (songInfo.tap_buffer && songInfo.tap_buffer >= 0) 
            {
                cons.log(`Using identified tap note buffer of ${songInfo.tap_buffer} ms...`);
                this.tap_buffer = songInfo.tap_buffer;
            } 
            
            // Any numbers less than 0 not accepted; use the default buffer in that case
            else 
            {
                cons.warn("No tap buffer defined, using default of " + DEFAULT_TAP_BUFFER + " ms...");
                this.tap_buffer = DEFAULT_TAP_BUFFER;
            }
            
            // Add buffer to the tap notes. The buffer window is defined from the song.ini, if given, or just use the default 115 ms.
            if (this.tap_buffer >= 0) 
                timeToAdd = this.tap_buffer;
            
            // Track has SysEx messages, guitar only for now
            if (sys && sys.length > 0) 
            {
                for (const ex of sys)
                {
                    if (ex.msg !== 'PHRASE')
                        continue;
                        
                    // Make sure it uses tap note phrase
                    if (ex.phrase !== 'TAPNOTES')
                        continue;
                        
                    // Wrong difficulty
                    if (ex.diff !== diff && ex.diff !== 'all')
                        continue;
                        
                    var msTime = Math.floor(ex.time * 1000);
                    var msLength = Math.floor(ex.length * 1000);
                    
                    var tapSectionEnd = msTime + msLength;
                    
                    // Find the note that is CLOSEST to the end of our tap section
                    // (Not the note that's in our tap section)
                    
                    var trk = this.data.tracks[instrument];
                    if (trk)
                    {
                        var noteTrack = (trk.diffs[diff] && trk.diffs[diff].notes) || [];
                        for (const note of noteTrack)
                        {
                            var noteMsTime = Math.floor(note.time * 1000);
                            if (noteMsTime < tapSectionEnd)
                                continue;
                                
                            var tapGap = (noteMsTime - tapSectionEnd);
                            
                            if (tapGap < timeToAdd && tapGap > 0)
                                timeToAdd = tapGap - 10;
                        }
                    }
                    
                    taps.push([msTime, msLength + timeToAdd, 1]); 
                }
            }
        }
            
        // --------------------------------
        // MANUAL TAP MARKERS
        
        var tapMarkerArray = this.data.arrays[instrument + "_taps"] || [];
         
        for (const tapMarker of tapMarkerArray)
        {
            var startMS = Math.floor(tapMarker[0] * 1000);
            var lengthMS = Math.floor(tapMarker[1] * 1000);

            taps.push([startMS, lengthMS + timeToAdd, 1]);
        }
         
        // --------------------------------
        // Sort tap array by time.
        
        taps.sort(function(a, b) { return a[0] - b[0]; });
        
        // --------------------------------
        
        if (taps.length <= 0)
        {
            this.CreateDummyArray(tapName, true);
            return;
        }
        else
        {
            var sa = new cls.SectionArray({itemName: 'SectionArray', id: tapName, parent: this.mainQB});
            var saa = new cls.ArrayArray({itemName: 'ArrayArray', parent: sa});
            
            for (const tap of taps)
            {
                var sai = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: saa});
                sai.values = tap;
            }
            
            return;
        }
        
        this.CreateDummyArray(tapName, true);
	}
	
	//-----------------------
	// Create drum fills
	//-----------------------
	
	CreateFillArray(diff, fillName)
	{
		var fills = [];
		
		var trk = this.data.tracks['drums'];
		var allowed = GHSDK.Config.SC_AllowDrumFills;
		
		var lastNoteTime = 0;
		
		if (trk && allowed)
		{
			var noteTrack = (trk.diffs[diff] && trk.diffs[diff].notes) || [];
			
			// Must have at least 2 notes for fill
			if (noteTrack.length >= 2)
			{
				for (var n=0; n<noteTrack.length-1; n++)
				{
					var thisNote = noteTrack[n];
					var nextNote = noteTrack[n+1];
					
					// Gap between note end and next note start
					var gap = nextNote.time - (thisNote.time + thisNote.length);
					
					// Notes are within drum fill thresh
					if (gap >= DRUM_FILL_MIN_TIME)
					{
						// End is always 100ms behind next note
						// Beginning is always 169-ish ms ahead of first note
						
						var msStart = Math.floor((thisNote.time + thisNote.length) * 1000.0) + 169;
						var msEnd = Math.floor(nextNote.time * 1000.0) - 100;

						// Subtract ms from each side so it's not DIRECTLY ON the note
						fills.push([msStart, msEnd]);
					}
				}
			}
			
			var lastNote = noteTrack[noteTrack.length-1];
			if (lastNote)
				lastNoteTime = lastNote.time;
		}
		
		// Create a FINAL drum fill
		// (GHWT songs expect the final drum fill to end when the song ends)
		
		var madeLastFill = false;
		
		if (lastNoteTime > 0)
		{
			var lastFillStart = lastNoteTime + 1.0;
			var lastFillEnd = this.converter.songEndTime;
			
			if (lastFillEnd > lastFillStart)
			{
				var start_ms = Math.floor(lastFillStart * 1000);
				var end_ms = Math.floor(lastFillEnd * 1000);
				
				fills.push([start_ms, end_ms]);
				
				var sai = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: saa});
				sai.values = [start_ms, end_ms];
				madeLastFill = true;
			}
		}
		
		if (!madeLastFill)
		{
			fills = [];
			cons.warn("Had fills but could not create ending fill. Skipping...");
		}
		
		if (fills.length <= 0)
			this.CreateDummyArray(fillName, true);
		else
		{
			var sa = new cls.SectionArray({itemName: 'SectionArray', id: fillName, parent: this.mainQB});
			var saa = new cls.ArrayArray({itemName: 'ArrayArray', parent: sa});
			
			for (const fill of fills)
			{
				//~ console.log(fillName, fill);
				var sai = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: saa});
				sai.values = fill;
			}
		}
	}
	
	//-----------------------
	// Format a lyric
	//-----------------------
	
	FormatLyric(txt)
	{
		// Expansion
		if (txt == '+')
			return '';
			
		// Remove unpitch
		var lastChar = txt[txt.length-1];
		if (lastChar == '#' || lastChar == '^')
			return txt.slice(0, txt.length-1);
			
		return txt;
	}
	
	//-----------------------
	// Create our massive QB with note info etc.
	// mysong.mid.qb
	//-----------------------
	
	CreateMainQB()
	{
		// List of items we'll output in sequence
		this.mainQB = new GHSDK.QBHandler.ReaderCore();
		
		// Stick our unknown constant GHWT header up top
		var buf = Buffer.from('1C0802041004080C0C0802041402040C10100C00', 'hex');
		var unk = ItemTypes.Create('Unknown', {bytes: buf, parent: this.mainQB});
		
		// -- TIMESIG -----------------------------------
		var tsl = ItemTypes.Create('SectionArray', {id: this.checksum + '_timesig', parent: this.mainQB});
		var tsa = ItemTypes.Create('ArrayArray', {parent: tsl});
		for (const tsig of this.data.timesigs)
		{
			var tsi = ItemTypes.Create('ArrayInteger', {parent: tsa});
			tsi.values = [tsig[0], tsig[1][0], tsig[1][1]];
		}
		
		// -- FRETBARS ----------------------------------
		var fbs = ItemTypes.Create('SectionArray', {id: this.checksum + '_fretbars', parent: this.mainQB});
		var fba = ItemTypes.Create('ArrayInteger', {parent: fbs});
		fba.values = this.data.fretbars;
		
		// -- PERFORMANCE -------------------------------
		var pfsec = ItemTypes.Create('SectionArray', {id: this.checksum + '_performance', parent: this.mainQB});
		var pfarr = ItemTypes.Create('ArrayStruct', {parent: pfsec});
		var pfsh = ItemTypes.Create('StructHeader', {parent: pfarr});
		ItemTypes.Create('StructItemInteger', {id: 'time', value: 0, parent: pfsh});
		var params = ItemTypes.Create('StructItemStruct', {id: 'params', parent: pfsh});
			var paramSH = ItemTypes.Create('StructHeader', {parent: params});
				ItemTypes.Create('StructItemQBKey', {id: 'clip', value: 'GSB_NoTempo_Begin_BOTR', parent: paramSH});
				ItemTypes.Create('StructItemInteger', {id: 'startframe', value: 200, parent: paramSH});
				ItemTypes.Create('StructItemInteger', {id: 'endframe', value: 330, parent: paramSH});

		// -- INSTRUMENTS -------------------------------
		this.AddInstruments();
		
		// -- DRUM NOTES --------------------------------
		this.CreateDrumAnimations();
		
		// -- CAMERAS -----------------------------------
		var camName = this.checksum + '_cameras_notes';
		if (this.converter.cameras)
		{
			var fbs = ItemTypes.Create('SectionArray', {id: camName, parent: this.mainQB});
			var fba = ItemTypes.Create('ArrayInteger', {parent: fbs});
			fba.values = this.converter.cameras;
		}
		else
			this.CreateDummyArray(camName, true);
		
		// -- LIGHTSHOW ---------------------------------
		this.CreateLightshow();
		
		// -- LEFT HAND NOTES ---------------------------
		this.CreateLeftHandNotes();
		
		// -- JUNK ARRAYS -------------------------------
		for (const ja of JunkArrays)
		{
			var jaID = ja.replace("mysong", this.checksum);
			this.CreateDummyArray(jaID, true);
		}
		
		// -- VOCALS / LYRICS ---------------------------
		// Vocals!
		var fbs = ItemTypes.Create('SectionArray', {id: this.checksum + '_song_vocals', parent: this.mainQB});
		var fba = ItemTypes.Create('ArrayInteger', {parent: fbs});
		
		var vData = this.data.vocalData;
		
		// Had no actual vocal notes
		if (vData && vData.notes && vData.notes.length <= 0)
			vData = null;
			
		if (!vData)
			cons.log("Writing dummy vocal data...", 'grey');
		
		if (vData)
			fba.values = vData.notes;
		else
			fba.values = [10000, 5000, 58];
		
		// Lyrics!
		var ls = ItemTypes.Create('SectionArray', {id: this.checksum + "_lyrics", parent: this.mainQB});
		var lss = ItemTypes.Create('ArrayStruct', {parent: ls});
		
		if (this.data.lyrics && this.data.lyrics.length > 0)
		{
			for (const lyric of this.data.lyrics)
			{
				var msTime = Math.floor(lyric[0] * 1000);
				msTime += GHSDK.Config.SC_VocalsOffset;
				
				var goodText = this.FormatLyric(lyric[1]);
				
				if (goodText)
				{
					var lssh = ItemTypes.Create('StructHeader', {parent: lss});
					ItemTypes.Create('StructItemInteger', {id: 'time', value: msTime, parent: lssh});
					ItemTypes.Create('StructItemString', {id: 'text', value: "\\L" + goodText, parent: lssh});
				}
			}
		}
		else
		{
			var lssh = ItemTypes.Create('StructHeader', {parent: lss});
			ItemTypes.Create('StructItemInteger', {id: 'time', value: 10000, parent: lssh});
			ItemTypes.Create('StructItemString', {id: 'text', value: "\\LNO LYRICS", parent: lssh});
		}
		
		// Freeform!
		this.CreateDummyArray(this.checksum + '_vocals_freeform', true);
		
		//~ var ff_arr = ItemTypes.Create('ArrayArray', {parent: ff_container});

		//~ var ff_child = ItemTypes.Create('ArrayInteger', {parent: ff_arr});
		//~ ff_child.values = [];
		
		// Phrases!
		var fbs = ItemTypes.Create('SectionArray', {id: this.checksum + '_vocals_phrases', parent: this.mainQB});
		var fba = ItemTypes.Create('ArrayInteger', {parent: fbs});
		
		if (vData)
		{
			fba.values = [0, 0];
			
			var lastPhraseTime = 0;
			
			for (const phrase of vData.phrases)
			{
				var msTime = Math.floor(phrase[0] * 1000);
				msTime += GHSDK.Config.SC_VocalsOffset;
				
				var count = phrase[2].length;
				
				fba.values.push(msTime);
				fba.values.push(count);
				
				lastPhraseTime = msTime + Math.floor(phrase[1] * 1000);
			}
			
			fba.values.push(lastPhraseTime);
			fba.values.push(0);
		}
		else
			fba.values = [0, 0, 10000, 1, 15000, 0];
		
		// Vocal note range
		var fbs = ItemTypes.Create('SectionArray', {id: this.checksum + '_vocals_note_range', parent: this.mainQB});
		var fba = ItemTypes.Create('ArrayInteger', {parent: fbs});
		
		if (vData)
			fba.values = [vData.pitchMin, vData.pitchMax];
		else
			fba.values = [128, 0];
		
		// -- BOSS BATTLE MARKERS -----------------------
		this.CreateDummyArray(this.checksum + "_BossBattleP1", true);
		this.CreateDummyArray(this.checksum + "_BossBattleP2", true);
		
		// -- SECTION MARKERS ---------------------------
		this.CreateDummyArray(this.checksum + "_rhythm_markers", true);
		this.CreateDummyArray(this.checksum + "_drum_markers", true);
		this.CreateDummyMarkers(this.checksum + "_vocals_markers");
		
		this.CreateRealMarkers('guitar');
		
		// -- OUTPUT AS TEXT -----------------------------------
		//~ var txt = this.mainQB.ToTextCore();
		//~ fs.writeFileSync(path.join(this.outDir, 'song.txt'), txt);
		
		return this.mainQB;
	}

	//-----------------------
	// Add instrument values
	//-----------------------
	
	AddInstruments()
	{
		for (const qbi of QBInstruments)
			this.AddInstrument(qbi);
	}
	
	//-----------------------
	// Add values for single instrument
	//-----------------------
	
	AddInstrument(qbi)
	{
		for (const diff of QBDiffs)
		{
			var dTrk = this.data.arrays[qbi.instrument + "_" + diff];
				
			// -- MAIN NOTE TRACK -----------------------------
			var dTrackName = this.checksum + "_" + qbi.noteID + "_" + diff;
			
			if (dTrk && dTrk.length)
			{
				var dSec = new cls.SectionArray({itemName: 'SectionArray', id: dTrackName, parent: this.mainQB});
                var dArr = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: dSec});
                dArr.values = dTrk;
			}
			else
				this.CreateDummyArray(dTrackName, true);
			
			// -- STAR POWER TRACK ----------------------------
			var subTrackBase = this.checksum + "_" + qbi.subID + (qbi.subID ? "_" : "") + diff;
			var sTrackName = subTrackBase + "_Star";
			
			var starArrays = this.data.arrays[qbi.instrument + "_" + diff + "_star"];
			if ((starArrays && starArrays.length <= 0) || !starArrays)
				this.CreateDummyStarPower(sTrackName);
			else
				this.CreateRealStarPower(sTrackName, starArrays);
			
			// -- BATTLE STAR POWER ---------------------------
			// Rudimentary fix for battle power phrases, just borrow SP phrases.
			var bTrackName = sTrackName + "BattleMode";

			var battleStarArrays = this.data.arrays[qbi.instrument + "_" + diff + "_star"];
			if ((battleStarArrays && battleStarArrays.length <= 0) || !battleStarArrays)
				this.CreateDummyStarPower(bTrackName);
			else
				this.CreateRealStarPower(bTrackName, battleStarArrays);
			
			// -- TAP NOTES -----------------------------------
			var tTrackName = subTrackBase + "_Tapping";
			this.CreateTapArray(qbi.instrument, diff, tTrackName);
			
			// -- WHAMMY CONTROLLER? --------------------------
			var wTrackName = subTrackBase + "_WhammyController";
			this.CreateDummyArray(wTrackName, true);
			
			// -- SOLOS (GHWT:DE) -----------------------------
			var soloTrackName = subTrackBase + "_SoloMarkers";
			this.CreateSoloArray(qbi.instrument, soloTrackName);
			
			// -- DRUM FILLS ----------------------------------
			if (qbi.instrument == "drums")
			{
				var dfTrackName = this.checksum + "_" + diff + "_DrumFill";
				this.CreateFillArray(diff, dfTrackName);
			}
			
			// -- DRUM UNMUTES --------------------------------
			if (qbi.instrument == "drums")
			{
				var dfTrackName = this.checksum + "_" + diff + "_DrumUnmute";
				this.CreateDummyArray(dfTrackName, true);
			}
		}
		
		var uscr = qbi.subID ? "_" : "";
		
		// -- FACE OFF STAR POWER -------------------------
		var fsTrackName = this.checksum + uscr + qbi.subID + "_FaceOffStar";
		this.CreateDummyStarPower(fsTrackName);

		// -- FACE OFF: P1 --------------------------------
		var fsTrackName = this.checksum + uscr + qbi.subID + "_FaceOffP1";
		this.CreateDummyArray(fsTrackName, true);
		
		// -- FACE OFF: P2 --------------------------------
		var fsTrackName = this.checksum + uscr + qbi.subID + "_FaceOffP2";
		this.CreateDummyArray(fsTrackName, true);
	}
	
	//-----------------------
	// Create script QB
	// mysong_song_scripts.qb
	//-----------------------
	
	CreateScriptQB()
	{
		// List of items we'll output in sequence
		this.scriptQB = new GHSDK.QBHandler.ReaderCore();
		
		// Stick our unknown constant GHWT header up top
		var buf = Buffer.from('1C0802041004080C0C0802041402040C10100C00', 'hex');
		var unk = new cls.Unknown({itemName: 'unknown', bytes: buf, parent: this.scriptQB});
		
		// -- STARTUP SCRIPT -----------------------------
		var ss = ItemTypes.Create('SectionScript', {id: this.checksum + "_song_startup", parent: this.scriptQB});
		
		// -- ANIM STRUCTS -------------------------------
		
		var stInstruments = [
			["guitar", "Judita", "Dan"],
			["Bass", "Ginger", "Sam"],
			["drum", "", ""],
			["Vocals", "Haley", "Josh"],
		];
		
		for (var g=0; g<2; g++)
		{
			var gender = (g == 0) ? "female" : "male";
			
			var secName = "car_" + gender + "_anim_struct_" + this.checksum;
			var mainSecBase = new cls.SectionStruct({itemName: 'SectionStruct', id: secName, parent: this.scriptQB});
			var mainSec = ItemTypes.Create('StructHeader', {parent: mainSecBase});

			for (const ins of stInstruments)
			{
				var insStructBase = new cls.StructItemStruct({itemName: 'StructItemStruct', id: ins[0], parent: mainSec}); 
				var insStruct = ItemTypes.Create('StructHeader', {parent: insStructBase});
				
				switch (ins[0].toLowerCase())
				{
					case 'guitar':
					case 'bass':
						var cName = ins[1 + g];
						var pakName = "L_GUIT_" + cName + "_Joker_anims";
						
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'pak', value: pakName, parent: insStruct});
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'anim_set', value: pakName + "_set", parent: insStruct});
						
						var fAnims = "guitarist_finger_anims_CAR_" + gender;
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'finger_anims', value: fAnims, parent: insStruct});
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'fret_anims', value: 'fret_anims_rocker', parent: insStruct});
						
						var strAnims = "CAR_" + gender + "_Normal";
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'strum_anims', value: strAnims, parent: insStruct});
						
						var facAnims = "facial_anims_" + gender + "_rocker";
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'facial_anims', value: facAnims, parent: insStruct});
						break;
						
					case 'drum':
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'pak', value: 'L_DRUM_Loops_Standard_anims', parent: insStruct});
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'anim_set', value: 'L_DRUM_Loops_Standard_anims_set', parent: insStruct});
						
						var facAnims = "facial_anims_" + gender + "_rocker";
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'facial_anims', value: facAnims, parent: insStruct});
						break;
						
					case 'vocals':
						var cName = ins[1 + g];
						var pakName = "L_SING_" + cName + "_Joker_anims";
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'pak', value: pakName, parent: insStruct});
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'anim_set', value: pakName + "_set", parent: insStruct});
						
						var facAnims = "facial_anims_" + gender + "_rocker";
						new cls.StructItemQBKey({itemName: 'StructItemQBKey', id: 'facial_anims', value: facAnims, parent: insStruct});
						break;
				}
			}
		}
		
		// Text debug
		//~ var txt = this.scriptQB.ToTextCore();
		//~ fs.writeFileSync(path.join(this.outDir, 'song_scripts.txt'), txt);
		
		return this.scriptQB;
	}
	
	//-----------------------
	// Create left-hand fretboard notes
	//-----------------------
	
	CreateLeftHandNotes()
	{
		var leftName = this.checksum + "_anim_notes";
		
		cons.log("Creating " + leftName + "...", 'grey');
		
		var finalNotes = [];
		var guitarTrack = this.data.tracks['guitar'];
		var bassTrack = this.data.tracks['bass'];
		
		for (var t=0; t<2; t++)
		{
			// Which track to get left-handed notes from?
			var theTrack = (t == 0) ? guitarTrack : bassTrack;
			
			if (!theTrack)
				continue;
			
			// Had no left-handed notes!
			if (theTrack.lefthand_notes.length <= 0)
				continue;
				
			for (const note of theTrack.lefthand_notes)
			{
				// Time in ms
				
				var qbNoteTime = Math.floor(note[0] * 1000.0);
				
				// Now let's get the note value!
				// First get the MIDI note we'll start from
				
				var midMin = (t == 0) ? LEFTHAND_MIN_GUITAR : LEFTHAND_MIN_BASS;
				var midNote = midMin + Math.floor(note[1] * LEFTHAND_AMOUNT);
				
				// Got the note, how long is it? in ms
				
				var midLength = Math.floor(note[2] * 1000.0);
				
				// Compress the note value
				finalNotes.push( [qbNoteTime, this.converter.CompressNote(midNote, 100, midLength)] );
			}
		}
		
		// Didn't create any notes...
		if (finalNotes.length <= 0)
		{
			cons.log("  No fretboard notes created.", 'grey');
			this.CreateDummyArray(leftName);
			return;
		}
		
		// Let's sort our list according to time
		finalNotes.sort(function(a, b) {return a[0] - b[0]});
		
		// Now let's create our final note list
		var fbs = new cls.SectionArray({itemName: 'SectionArray', id: leftName, parent: this.mainQB});
		var fba = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: fbs});
		var qbNotes = [];
		
		for (const note of finalNotes)
		{
			qbNotes.push(note[0]);
			qbNotes.push(note[1]);
		}
		
		fba.values = qbNotes;
	}
	
	//-----------------------
	// Create lightshow notes
	//-----------------------
	
	CreateLightshow()
	{
		var lsName = this.checksum + "_lightshow_notes";
		
		if (this.customLightshow)
		{
			// Final drum array
			var fbs = new cls.SectionArray({itemName: 'SectionArray', id: lsName, parent: this.mainQB});
			var fba = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: fbs});
			fba.values = this.customLightshow;
			
			cons.log("Using custom lightshow array...", 'grey');
		}
        
        else if (this.data.lightshow && this.data.lightshow.length)
        {
            // Final drum array
			var fbs = new cls.SectionArray({itemName: 'SectionArray', id: lsName, parent: this.mainQB});
			var fba = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: fbs});
            
            var lsData = [];
            for (const note of this.data.lightshow)
            {
                lsData.push(Math.floor(note.time * 1000.0));
                lsData.push(this.converter.CompressNote(note.note, 100, Math.floor(note.duration * 1000.0)));
            }
            
            fba.values = lsData;
            
            cons.log("Using lightshow from LIGHTSHOW track...", 'grey');
        }
		
		else
			this.CreateDummyArray(lsName, true);
	}
	
	//-----------------------
	//
	// Create drum animation for note data
	//
	//            ANIM
	//  FLAGS?     |        LENGTH
	//  __|___   __|___   ___|__________
	// |      | |      | |              |
	// 01111111 01010011 0000000000011101
	//	
	// STOCK DRUMMER ANIMS:
	// (Internally, these are subtracted from 73)
	//
	// 73: kick pedal
	// 74: tom_3 (right)
	// 75: tom_2 (middle)
	// 76: tom_1 (left)
	// 77: snare
	// 78: hi-hat (closed)
	// 79: hi-hat (open)
	// 80: cymbal_3 (right)
	// 81: cymbal_1 (left)
	// 82: cymbal_2 (middle)
	//
	// SPECIAL:
	// 83: stick clap
	//
	//-----------------------
	
	CreateDrumAnimCodes(note)
	{
		var codes = [];
		
		for (const fret of note.frets)
		{
			var code = 0;
			
			var anim = 0;
			
			// SUPER BASIC DRUM ANIMS
			if (fret == 'red')
				anim = 77;
			if (fret == 'green')
				anim = 74;
			if (fret == 'blue')
				anim = 76;
			if (fret == 'orange')
				anim = 80;
			if (fret == 'yellow')
				anim = 79;
			if (fret == 'purple')
				anim = 73;

			code += (anim << 16);
			
			// Flags... or something...
			var flags = 127;
			code += (flags << 24);

			// Ensure length doesn't exceed 2 bytes
			var msLen = Math.min(65535, Math.floor(note.length * 1000));
			code += msLen;
			
			codes.push(code);
		}

		return codes;
	}
	
	//-----------------------
	// Create drum animation array from drums
	//-----------------------
	
	CreateDrumAnimations()
	{
		var sectionName = this.checksum + "_drums_notes";
		var drumNotes = [];
		var trk = this.data.tracks['drums'];
		
		// Get ANY track
		if (trk)
			drumNotes = (trk.diffs.expert && trk.diffs.expert.notes) || [];
	
		// No valid drum notes for anims, ignore
		if (!drumNotes.length)
		{
			this.CreateDummyArray(sectionName);
			return;
		}
		
		var drumArr = [];
		
		for (const note of drumNotes)
		{
			var msTime = Math.floor(note.time * 1000);

			var noteCodes = this.CreateDrumAnimCodes(note);
			for (const code of noteCodes)
			{
				drumArr.push(msTime);
				drumArr.push(code);
			}
		}
		
		// Final drum array
		var fbs = new cls.SectionArray({itemName: 'SectionArray', id: sectionName, parent: this.mainQB});
		
		if (drumArr.length)
		{
			var fba = new cls.ArrayInteger({itemName: 'ArrayInteger', parent: fbs});
			fba.values = drumArr;
		}
		else
		{
			var flt = new cls.Floats({itemName: 'Floats', parent: fbs});
			flt.values = [0.0, 0.0];
		}
	}
	
	//-----------------------
	// Generate song checksum from a folder
	//-----------------------
	
	GenerateSongChecksum(info)
	{
		var nm = info.name;
		
		if (!nm)
		{
			cons.error("'name' field was absent from INI.");
			return;
		}
		
		nm = nm.toString();
		
		// Replace foreign letters
		for (const fgn of Foreigns)
		{
			if (nm.indexOf(fgn[0]) >= 0)
			{
				var pat = new RegExp(fgn[0], "g");
				nm = nm.replace(pat, fgn[1]);
			}
		}
		
		// Slice into words
		var words = nm.split(" ");
		var str = "";
		
		for (var word of words)
		{
			// We only want letters, numbers
			word = word.toString().toLowerCase().replace(/[^A-Za-z0-9]/g, '');
			
			if (str.length + word.length >= 24)
				break;
			else
				str += word;
		}
		
		this.checksum = str;
	}
}

module.exports = Conversion;
